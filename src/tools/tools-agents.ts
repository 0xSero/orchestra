import { tool } from "@opencode-ai/plugin";
import { mkdir, readFile, rm, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { dirname, join } from "node:path";
import { getProfile } from "../config/profiles";
import { buildToolConfigFromPermissions } from "../permissions/validator";
import { normalizeModelInput } from "./normalize-model";
import {
  getClient,
  getDefaultListFormat,
  getDirectory,
  getModelAliases,
  getModelSelection,
  getProfiles,
} from "./state";
import { renderMarkdownTable } from "./markdown";

type WorkerAgentRecord = {
  agentId: string;
  workerId: string;
  createdAt: number;
  expiresAt?: number;
  filePath: string;
  previousContent?: string;
  timer?: NodeJS.Timeout;
};

const workerAgents = new Map<string, WorkerAgentRecord>();

function toAgentId(workerId: string, agentId?: string): string {
  return agentId ?? `worker-${workerId}`;
}

function agentFilePath(directory: string, agentId: string): { dir: string; path: string } {
  const parts = agentId.split("/").filter(Boolean);
  const name = parts.pop() ?? agentId;
  const dir = join(directory, ".opencode", "agent", ...parts);
  return { dir, path: join(dir, `${name}.md`) };
}

function yamlScalar(value: string): string {
  if (value.length === 0) return "\"\"";
  if (/[:#\n]/.test(value)) return JSON.stringify(value);
  return value;
}

function buildAgentFileContent(input: {
  description: string;
  mode: "primary" | "subagent" | "all";
  model: string;
  temperature?: number;
  tools?: Record<string, boolean>;
  prompt: string;
}): string {
  const lines: string[] = ["---"];
  lines.push(`description: ${yamlScalar(input.description)}`);
  lines.push(`mode: ${input.mode}`);
  lines.push(`model: ${input.model}`);
  if (typeof input.temperature === "number") {
    lines.push(`temperature: ${input.temperature}`);
  }
  if (input.tools && Object.keys(input.tools).length > 0) {
    lines.push("tools:");
    for (const key of Object.keys(input.tools).sort()) {
      lines.push(`  ${key}: ${input.tools[key] ? "true" : "false"}`);
    }
  }
  lines.push("---", "", "<!-- generated by opencode-orchestrator -->", "", input.prompt.trim(), "");
  return lines.join("\n");
}

async function readAgentFile(path: string): Promise<string | undefined> {
  if (!existsSync(path)) return undefined;
  try {
    return await readFile(path, "utf8");
  } catch {
    return undefined;
  }
}

export const enableWorkerAgent = tool({
  description: "Temporarily expose a worker profile as an OpenCode agent (writes .opencode/agent/<id>.md).",
  args: {
    workerId: tool.schema.string().describe("Worker profile ID to mirror as an agent"),
    agentId: tool.schema.string().optional().describe("Agent ID to register (default: worker-<id>)"),
    mode: tool.schema.enum(["primary", "subagent", "all"]).optional().describe("Agent mode (default: subagent)"),
    ttlMs: tool.schema.number().optional().describe("Auto-disable after this many ms (default: never)"),
    force: tool.schema.boolean().optional().describe("Overwrite existing agent ID if present"),
  },
  async execute(args) {
    const profiles = getProfiles();
    const profile = getProfile(args.workerId, profiles);
    if (!profile) return `Unknown profile "${args.workerId}".`;

    const agentId = toAgentId(profile.id, args.agentId);
    const directory = getDirectory();
    const existingRecord = workerAgents.get(agentId);
    if (existingRecord && !args.force) {
      return `Agent "${agentId}" already exists. Pass force=true to overwrite.`;
    }

    const modelSpec = profile.model.trim();
    const isNodeTag = modelSpec.startsWith("auto") || modelSpec.startsWith("node");
    const isExplicitModel = modelSpec.includes("/");
    let resolvedModel = modelSpec;

    if (isNodeTag || !isExplicitModel) {
      const client = getClient();
      if (!client) return "OpenCode client not available; restart OpenCode.";
      const normalized = await normalizeModelInput(profile.model, {
        client,
        directory,
        modelSelection: getModelSelection(),
        modelAliases: getModelAliases(),
      });
      if (!normalized.ok) return normalized.error;
      resolvedModel = normalized.model;
    }

    const tools = buildToolConfigFromPermissions({
      permissions: profile.permissions,
      baseTools: profile.tools,
    });
    const prompt =
      profile.systemPrompt ??
      [
        `You are the ${profile.name}.`,
        profile.purpose,
        "",
        "Focus on this role and provide concise, high-quality output.",
      ].join("\n");

    const description = `Worker agent: ${profile.name}`;
    const mode = args.mode ?? "subagent";
    const file = agentFilePath(directory, agentId);
    const previousContent = await readAgentFile(file.path);
    if (previousContent && !args.force) {
      return `Agent "${agentId}" already exists on disk. Pass force=true to overwrite.`;
    }
    await mkdir(file.dir, { recursive: true });

    const content = buildAgentFileContent({
      description,
      mode,
      model: resolvedModel,
      temperature: profile.temperature,
      tools: tools,
      prompt,
    });
    await writeFile(file.path, content, "utf8");

    const record: WorkerAgentRecord = {
      agentId,
      workerId: profile.id,
      createdAt: Date.now(),
      expiresAt: typeof args.ttlMs === "number" && args.ttlMs > 0 ? Date.now() + args.ttlMs : undefined,
      filePath: file.path,
      previousContent,
    };

    if (record.expiresAt) {
      record.timer = setTimeout(() => {
        void disableWorkerAgent.execute({ agentId }, {} as any);
      }, Math.max(0, record.expiresAt - Date.now()));
    }

    workerAgents.set(agentId, record);

    return `Enabled worker agent "${agentId}" for profile "${profile.id}".`;
  },
});

export const disableWorkerAgent = tool({
  description: "Disable a temporary worker agent (removes generated agent file).",
  args: {
    agentId: tool.schema.string().optional().describe("Agent ID to disable"),
    workerId: tool.schema.string().optional().describe("Worker profile ID (default: worker-<id>)"),
  },
  async execute(args) {
    const workerId = args.workerId;
    const agentId = args.agentId ?? (workerId ? toAgentId(workerId) : undefined);
    if (!agentId) return "Provide agentId or workerId.";

    const record = workerAgents.get(agentId);
    const directory = getDirectory();
    const file = agentFilePath(directory, agentId);

    if (record?.previousContent !== undefined) {
      await mkdir(dirname(file.path), { recursive: true });
      await writeFile(file.path, record.previousContent, "utf8");
    } else if (existsSync(file.path)) {
      const existing = await readAgentFile(file.path);
      if (record || (existing && existing.includes("generated by opencode-orchestrator"))) {
        await rm(file.path, { force: true });
      }
    }

    if (record?.timer) clearTimeout(record.timer);
    workerAgents.delete(agentId);

    return `Disabled worker agent "${agentId}".`;
  },
});

export const listWorkerAgents = tool({
  description: "List active temporary worker agents registered by the orchestrator.",
  args: {
    format: tool.schema.enum(["markdown", "json"]).optional().describe("Output format (default: markdown)"),
  },
  async execute(args) {
    const format: "markdown" | "json" = args.format ?? getDefaultListFormat();
    const rows = [...workerAgents.values()].map((entry) => ({
      agentId: entry.agentId,
      workerId: entry.workerId,
      filePath: entry.filePath,
      createdAt: new Date(entry.createdAt).toISOString(),
      expiresAt: entry.expiresAt ? new Date(entry.expiresAt).toISOString() : "never",
    }));

    if (format === "json") return JSON.stringify(rows, null, 2);
    if (rows.length === 0) return "No temporary worker agents registered.";

    return renderMarkdownTable(
      ["Agent ID", "Worker ID", "File", "Created", "Expires"],
      rows.map((r) => [r.agentId, r.workerId, r.filePath, r.createdAt, r.expiresAt])
    );
  },
});
